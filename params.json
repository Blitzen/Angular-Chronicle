{"name":"Angular-Chronicle","tagline":"An undo/redo library for AngularJS","body":"# **Chronicle**\r\nAn undo/redo service for AngularJS.\r\n\r\nNote: Since the current version is not yet at 1.x.x, there is the\r\nchance of API changes that could fundamentally wreck certain\r\nfunctionality. Use this beta at your own risk.\r\n\r\n## **Installation**\r\nThe easiest way to install is just to use [Bower](http://bower.io/\r\n\"Bower\").\r\n\r\n```javscript\r\nbower install chronicle\r\n```\r\n\r\nHowever if you aren't using Bower, you can simply take the\r\n[`chronicle.js`](https://github.com/Blitzen/Angular-Chronicle/blob/master/chronicle.js \"chronicle.js\")\r\nfile and put it in your project and include\r\nit in your html file after you include your AngularJS source file.\r\n\r\n## **Examples**\r\n[Here](http://blitzen.github.io/Angular-Chronicle \"Chronicle Website\")\r\nis Chronicle's official page, and it contains a number of useful\r\nexamples that cover different supported pieces of functionality.\r\n\r\n## **Basic Usage**\r\nFirst things first, you have to start recording your variable:\r\n\r\n```javascript\r\n$scope.str = 'test';\r\n$scope.chronicle = Chronicle.record('str', $scope);\r\n```\r\n\r\nYou then take this scope variable and call functions on it.\r\n\r\n```javascript\r\n$scope.chronicle.undo();\r\n$scope.chronicle.redo();\r\n$scope.chronicle.canUndo();\r\n$scope.chronicle.canRedo();\r\n```\r\n\r\nThese functions should be self explanitory.\r\n[This](http://blitzen.github.io/Angular-Chronicle/#basic-example) should\r\nbe enough for basic undo/redo functionality.\r\n\r\n## **Full Usage**\r\nAt the moment, there are only four arguments you can give\r\n`Chronicle.record`.\r\n\r\n```javascript\r\n$scope.chron = Chronicle.record('watchVar', $scope, handleStringsBool, 'noWatchVar');\r\n```\r\n\r\n[`'watchVar'`](#watch-variable) is the stringified variable you want to\r\nbe able to undo on.\r\n\r\n[`scope`](#scope) is the variable that contains your watch variable and\r\nyour unwatched variables.\r\n\r\n[`handleStringsBool`](#string-handling) is the variable that determines\r\nif you want to handle strings in a more user input friendly way.\r\n\r\n[`noWatchVar`](#no-watch-variables) is the stringified variable that you\r\nwant to be able to store alongside your watch variable but not trigger\r\nyour watch variable.\r\n\r\nThe functions that you can then use on `$scope.chron`:\r\n\r\n```javascript\r\n$scope.chron.undo();\r\n```\r\n\r\nUndoes to the previous change.\r\n\r\n```javascript\r\n$scope.chron.redo();\r\n```\r\n\r\nRedoes to the next change.\r\n\r\n```javascript\r\n$scope.chron.addOnUndoFunction(fn);\r\n$scope.chron.addOnRedoFunction(fn);\r\n$scope.chron.addOnAdjustFunction(fn);\r\n```\r\n\r\nUse these functions to make Chronicle call a function whenever a\r\nsignificant event happens to the Chronicle object.\r\n\r\n```javascript\r\n$scope.chron.removeOnUndoFunction(fn);\r\n$scope.chron.removeOnRedoFunction(fn);\r\n$scope.chron.removeOnAdjustFunction(fn);\r\n```\r\n\r\nRemoves the passed function call on the event. More info on the above 6\r\nfunctions [here](#on-event-handlers).\r\n\r\n```javascript\r\n$scope.chron.canUndo();\r\n$scope.chron.canRedo();\r\n```\r\n\r\nReturns true if the action can be performed, false if you can't perform\r\nthe action at the current time.\r\n\r\n## **Watch Variable**\r\nThis parameter must be a string version of how you access the variable\r\nyou want to watch. For example:\r\n\r\n```javascript\r\n$scope.obj.arrOfObjs[2].foo //The var you want to watch\r\n\r\n$scope.chronicle = Chronicle.record('obj.arrOfObjs[2].foo', $scope); //This is valid\r\n$scope.chronicle = Chronicle.record(obj.arrOfObjs[2].foo, $scope); //invalid\r\nvar index = 2;\r\n$scope.chronicle = Chronicle.record('obj.arrOfObjs[index].foo', $scope); //invalid\r\n```\r\n\r\nGenerally good practice would be to avoid trying to watch a specific\r\nvariable in an array. However watching a specific variable in an object\r\nis just fine.\r\n\r\nThe watch will record the entire variable. So if the watch variable is\r\nan object or array, it will watch everything in the object/array:\r\n\r\n```javascript\r\n$scope.obj = {};\r\n$scope.obj.arr = [1, 2, 3];\r\n$scope.obj.str = 'abc';\r\n\r\n$scope.chronicle = Chronicle.record('obj', $scope);\r\n...\r\n$scope.obj.newVar = 123; //New thing to undo\r\n...\r\n$scope.arr[0] = 4; //New thing to undo\r\n...\r\n$scope.str += 'def'; //New thing to undo.\r\n```\r\n\r\n## **Scope**\r\nThis is the scope of the controller with the variable you want to watch.\r\n`$scope` can be used.\r\n\r\n### Controller As Syntax\r\nThis library fully supports \"controller as\" syntax. So everything will work\r\njust the same as using `$scope`, just replace `$scope` with `this`:\r\n\r\n```javascript\r\nthis.watchThis = 'something'\r\nthis.chronicle = Chronicle.record('watchThis', this);\r\n```\r\n\r\nAs well as:\r\n```javascript\r\nvar vm = this;\r\nvm.watchThis = {};\r\nvm.chronicle = Chronicle.record('watchThis', vm);\r\n```\r\n\r\n\r\n## **String Handling**\r\nThis service provides an option for handling strings in a special way.\r\nThis option was designed with text inputs in mind - no user wants an\r\nundo to change only a single character each time. String handling is by\r\ndefault not active.\r\n\r\nTo enable this, pass `true` to the third arguement on\r\n`Chronicle.record`.\r\n\r\n```javascript\r\n$scope.undoRedo = Chronicle.record('var', $scope, true); // turns string handling on\r\n```\r\n\r\n### Specific Details on String Handling\r\nSpecific string handling, when on, works like this:\r\nThe newest update is always kept. However if the newest update is\r\nconsidered to be too similar to the update before it, it removes the\r\nupdate before it completely. Too similar is defined as:\r\n\r\n- One string contains the other string completely, in order, with only 1\r\n  place where the longer string contains extra characters.\r\n\r\n- The longer string is no more than 5 characters longer than the shorter\r\n  string (this number can be changed - it is the variable\r\n  `MAX_STRING_CHANGE_SIZE` at the top of\r\n[`chronicle.js`](https://github.com/Blitzen/Angular-Chronicle/blob/dev/chronicle.js/#L4 \"chronicle.js line 4\")\r\n\r\n- The longer string has no whitespace in the extra characters\r\n\r\n[Here (not here yet!!)](http://blitzen.github.io/Angular-Chronicle \"Chronicle Website\")\r\nis a demo of string specific handling in action.\r\n\r\n## **No Watch Variables**\r\nYou have the option to provide secondary variable(s) to Chronicle which\r\nwill be stored whenever your watch variable is changed but, if changed,\r\nwill not trigger a new undo location. This looks like so:\r\n\r\n```javascript\r\n$scope.watchThis = 'abc';\r\n$scope.dontWatchThis = 'ignored';\r\n$scope.chron = Chronicle.record('watchThis', $scope, false, 'dontWatchThis');\r\n\r\n```\r\n\r\nSince the no watch variable option is the fourth one, be sure to pass\r\nthe string handling variable before it, even if you don't intend to use\r\nthat functionality (just pass `false` in that case).\r\n\r\nYou can also pass in an array of no watch variables to tie a number of\r\nthem to the Chronicle object (note - this does NOT work with watch\r\nvariables, you may only have one watch variable).\r\n\r\n```javascript\r\n$scope.watchThis = 'abc';\r\n$scope.dontWatchThis = 12;\r\n$scope.norThis = \"I'm being\";\r\n$scope.ignorePlease = {};\r\n$scope.chron = Chronicle.record('watchThis', $scope, false, ['dontWatchThis', 'norThis', 'ignorePlease']);\r\n...\r\n$scope.dontWatchThis = 5;\r\n...\r\n$scope.watchThis = 'cba';\r\n...\r\n$scope.ignorePlease.member = 3;\r\n$scope.norThis += \" ignored\";\r\n...\r\n$scope.watchThis = 'abcdefg';\r\n...\r\n$scope.ignorePlease.member = 1000;\r\n//So currently\r\n//watchThis='abcdefg', dontWatchThis = 5,\r\n//norThis = \"I'm being ignored\", ignorePlease = {member: 1000}\r\n...\r\n$scope.chron.undo();\r\n//So now\r\n//watchThis='cba', dontWatchThis = 5,\r\n//norThis = \"I'm being\", ignorePlease = {}\r\n...\r\n$scope.chron.undo();\r\n//So now\r\n//watchThis='abc', dontWatchThis = 12,\r\n//norThis = \"I'm being\", ignorePlease = {}\r\n...\r\n$scope.chron.redo();\r\n$scope.chron.redo();\r\n//So now\r\n//watchThis='abcdefg', dontWatchThis = 5,\r\n//norThis = \"I'm being ignored\", ignorePlease = {member: 3}\r\n```\r\n\r\n## **On Event Handlers**\r\nYou may want to perform a certain function when something happens in\r\nyour Chronicle object. In order to do that, you may do as follows:\r\n\r\n```javascript\r\n$scope.chron.addOnUndoFunction($scope.fn)\r\n```\r\n\r\nThis will make Chronicle call `$scope.fn()` whenever the `$scope.chron` object\r\nsucessfully undoes.\r\n\r\n```javascript\r\n$scope.chron.addOnRedoFunction($scope.fn)\r\n```\r\n\r\nThis will make Chronicle call `$scope.fn()` whenever the `$scope.chron` object\r\nsucessfully redoes.\r\n\r\n```javascript\r\n$scope.chron.addOnAdjustFunction($scope.fn)\r\n```\r\n\r\nThis will make Chronicle call `$scope.fn()` whenever the `$scope.chron` object\r\nsucessfully registers a change that is *not* an undo or redo - bascially any update\r\nto the model that isn't caused by a direct call to `undo()` or `redo()`.\r\n\r\nIf you wish to call a function with arguements, I suggest the following\r\nstructure, as at the moment Chronicle does not support that directly:\r\n\r\n```javascript\r\n$scope.fn = function(passedVars){...} //The function that you wish to call\r\n$scope.intermediatefn = function() {\r\n  var passingVars = ...//Get vars\r\n  $scope.fn(passingVars);\r\n}\r\n...\r\n$scope.chron.addOnAdjustFunction($scope.intermediatefn);\r\n```\r\n\r\nAnd if at any point you wish to remove any of these onEvent functions,\r\njust use `$scope.watchObj.removeOnEventFunction($scope.fn)`, where `Event` can be `Undo`,\r\n`Redo`, or `Adjust`.\r\n\r\nBy @Blitzen, @SamMaier","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}